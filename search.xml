<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F2018%2F04%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式抽象工厂的工作就是将抽象零件组装为抽象产品，也就是我们并不关心零件的具体实现，而是只关心接口（API）。 示例抽象的零件：Item类abstract class Item &#123;123456 protected String caption; public Item(String caption) &#123; this.caption = caption; &#125; public abstract String makeHTML();//抽象方法由子类实现&#125; 抽象的零件：Link类abstract class Link extends Item &#123;123456 protected String url; public Link(String caption, String url) &#123; super(caption); this.url = url; &#125;&#125; 抽象的零件：Tray类abstract class Tray extends Item &#123;12345678 protected ArrayList tray = new ArrayList(); public Tray(String caption) &#123; super(caption); &#125; public void add(Item item) &#123; tray.add(item); &#125;&#125; 抽象的产品：Page类abstract class Page &#123;1234567891011121314151617181920212223 protected String title; protected String author; protected ArrayList content = new ArrayList(); public Page(String title, String author) &#123; this.title = title; this.author = author; &#125; public void add(Item item) &#123; content.add(item); &#125; public void output() &#123; try &#123; String filename = title + &quot;.html&quot;; Writer writer = new FileWriter(filename); writer.write(this.makeHTML()); writer.close(); System.out.println(filename + &quot; 编写完成。&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public abstract String makeHTML();&#125; 抽象的工厂：Factory类getFactory()通过调用Class类的forName方法动态地读取类信息，接着用newInstance方法生成该类的实例，并将其作为返回值返回调用者。 请注意：虽然getFactory()方法生成的是具体工厂的实例，但是返回值是抽象工厂类型的。 abstract class Factory &#123;123456789101112131415 public static Factory getFactory(String classname) &#123; Factory factory = null; try &#123; factory = (Factory)Class.forName(classname).newInstance(); &#125; catch (ClassNotFoundException e) &#123; System.err.println(&quot;没有找到 &quot; + classname + &quot;类。&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return factory; &#125; public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String title, String author);&#125; 具体的工厂：ListFactory类class ListFactory extends Factory &#123;12345678910 public Link createLink(String caption, String url) &#123; return new ListLink(caption, url); &#125; public Tray createTray(String caption) &#123; return new ListTray(caption); &#125; public Page createPage(String title, String author) &#123; return new ListPage(title, author); &#125;&#125; 具体的零件：ListLink类class ListLink extends Link &#123;1234567 public ListLink(String caption, String url) &#123; super(caption, url); &#125; public String makeHTML() &#123; return &quot; &lt;li&gt;&lt;a href=\&quot;&quot; + url + &quot;\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&lt;/li&gt;\n&quot;; &#125;&#125; 具体的零件：ListTray类划重点：通过使用迭代器，调用Item的makeHTML()，请注意，这里并不关心变量Item中保存的实例究竟是ListLink的实例还是ListTray的实例，只是简单的调用makeHTML(),之后item会帮我们处理，这是面向对象编程的好处。 class ListTray extends Tray &#123;123456789101112131415161718 public ListTray(String caption) &#123; super(caption); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append(&quot;&lt;li&gt;\n&quot;); buffer.append(caption + &quot;\n&quot;); buffer.append(&quot;&lt;ul&gt;\n&quot;); Iterator it = tray.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append(&quot;&lt;/ul&gt;\n&quot;); buffer.append(&quot;&lt;/li&gt;\n&quot;); return buffer.toString(); &#125;&#125; 具体的产品：ListPage类class ListPage extends Page &#123;1234567891011121314151617181920 public ListPage(String title, String author) &#123; super(title, author); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;); buffer.append(&quot;&lt;body&gt;\n&quot;); buffer.append(&quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot;); buffer.append(&quot;&lt;ul&gt;\n&quot;); Iterator it = content.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append(&quot;&lt;/ul&gt;\n&quot;); buffer.append(&quot;&lt;hr&gt;&lt;address&gt;&quot; + author + &quot;&lt;/address&gt;&quot;); buffer.append(&quot;&lt;/body&gt;&lt;/html&gt;\n&quot;); return buffer.toString(); &#125;&#125; 使用工厂将零件组装成为产品：Main类该类只是引入了factory包，并没有使用任何具体的零件，产品和工厂 class Main &#123;12345678910111213141516171819202122232425262728293031323334353637 public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println(&quot;Usage: java Main class.name.of.ConcreteFactory&quot;); System.out.println(&quot;Example 1: java Main listfactory.ListFactory&quot;); System.out.println(&quot;Example 2: java Main tablefactory.TableFactory&quot;); System.exit(0); &#125; // Factory factory = Factory.getFactory(&quot;abstractFactory.listfactory.ListFactory&quot;); Factory factory = Factory.getFactory(args[0]); Link people = factory.createLink(&quot;People Daily&quot;, &quot;http://www.people.com.cn/&quot;); Link gmw = factory.createLink(&quot;GuangMing Daily&quot;, &quot;http://www.gmw.cn/&quot;); Link us_yahoo = factory.createLink(&quot;Yahoo!&quot;, &quot;http://www.yahoo.com/&quot;); Link jp_yahoo = factory.createLink(&quot;Yahoo!Japan&quot;, &quot;http://www.yahoo.co.jp/&quot;); Link excite = factory.createLink(&quot;Excite&quot;, &quot;http://www.excite.com/&quot;); Link google = factory.createLink(&quot;Google&quot;, &quot;http://www.google.com/&quot;); Tray traynews = factory.createTray(&quot;NewsPaper&quot;); traynews.add(people); traynews.add(gmw); Tray trayyahoo = factory.createTray(&quot;Yahoo!&quot;); trayyahoo.add(us_yahoo); trayyahoo.add(jp_yahoo); Tray traysearch = factory.createTray(&quot;searchEngine&quot;); traysearch.add(trayyahoo); traysearch.add(excite); traysearch.add(google); Page page = factory.createPage(&quot;LinkPage&quot;, &quot;kr&quot;); page.add(traynews); page.add(traysearch); page.output(); &#125;&#125; 抽象工厂的优劣点####易于增加具体的工厂 这里说的容易是指需要编写哪些类和需要实现哪些方法都非常清楚。假设我们要在示例中增加新的具体工厂，那么需要做的就是编写Factory，Link，Tray，Page这四个类的子类，并实现他们定义的抽象方法。这样一来，无论要增加多少个具体工厂（或者是修改具体工厂的BUG），都无需修改抽象工厂。 ####难于增加新的零件 如果要增加新的零件时，就必须要对所有的具体工厂进行相应的修改。例如要在factory包中增加一个表示图像的Picture零件，就要在listfactory中作如下修改： 在ListFactory中加入createPicture； 新增ListPicture类 而且编写完成的具体工厂越多，修改的工作量越多。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式 抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对抖音和快手的体验与分析]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%AF%B9%E6%8A%96%E9%9F%B3%E5%92%8C%E5%BF%AB%E6%89%8B%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[序言虽然以前就听过快手和抖音了，但好似对我的作用不大，就一直没有上手。But，快手和抖音都在2018的春节期间大放异彩，逐步占领市场。还有看到了中央颁布的互联网独角兽公司，我惊奇地发现快手竟然排到了61，而抖音也是有前一百的，被学生党喜闻乐见的知乎排在了110+。果然人民群众相对于.txt,.jpg,更喜欢*.avi啊。所以决定下载抖音和快手，来体验一下，顺便来为我拓宽一下设计思路。 界面和交互设计抖音的界面初始只有一个视频，不用点击就自动播放，双击点赞，上下滑下一个视频，很简单方便，但可选率低。而快手初始界面四张图片，需要点击进去才能播放，下滑可以看更多的缩略图。抖音的设计必须依靠强大的推荐系统，不然滑了几个视频都是不好看的就gg了。 推荐系统和算法毕竟一开始还是要给三无用户作推荐，大概是推荐点赞比较多的和关注度比较高的大v吧。而抖音请了明星入驻，一点开的都是明星的视频，而快手更多的是妹纸的，不过标题真的太太太尴尬了。那么如何给新用户增加曝光机会呢？ 在视频推荐中会穿插一些新用户的视频，我的观察大概是10条有1条。这样保证了在用户不会觉得烦的同时，也给了新的创作者一定流量。当新的视频达到一定的赞后，可能会被推送更多用户，而没有达到某个标准的视频可能会“进入冷宫“。这样的设计防止了像微博这类网站的大V把持流量所造成的马太效应，越来越多的平台在采取相同的策略 这样就能吸引新用户，增加优质资源的同时防止大v的流量劫持。 内容抖音的内容还算是积极向上，明星们都比较接地气，而且配上特定的BGM真的很魔性，还有一些人拍的情景剧，也就十秒左右，后来发现还是续集来的，orz。 而快手的内容就比较接地气，或者是少部分人说的俗，视频里主要是妹子跳舞，泳装…..还有农村里面的奇人异事，工厂妹的一天之类的。我觉得快手是切入点很准，面向二线三线四线的人，得屌丝者得天下啊。 不过上一次的十四岁怀孕少女的视频引起了人们的关注，进而对快手的鄙视，我还在live中发现了色情引流，虽然说可以举报，但管理员根本忙不过来啊。 监管这一方面还要加强吧，感觉要变成直播软件了。共青团入驻快手和抖音，我还特意搜了账号看作品，作品量低啊。 推荐广告这种流量软件当然少不了广告的，不然怎生存，穿插于视频中，用户不仔细看可能就已经当成一个普通视频看完了。我刚注册，广告遇见率不高，可能还是杀熟吧。再者听说抖音和快手的广告费是比知乎高几倍的，果然还是学生党比屌丝更穷啊。 结语抖音和快手的界面和交互设计都做得很好，也很快（只是我的辣鸡校园网不给力），智能推荐也很好，但过于沉溺于某个方面就会错过外面精彩的世界。就好像快手现在就只推荐都是妹纸的视频给我了，明明我本意是用快手和抖音记单词的。我觉得俗或不俗都是人民群众说了算，快手和抖音都是一个成功的app，既满足了人民的需求也从中捞到了利益。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Iterator模式]]></title>
    <url>%2F2018%2F04%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Iterator模式刚看完23种设计模式，就先来总结一下Iterator模式。重点是掌握使用抽象类和接口来编程。先来回忆一下这个例子： 定义Aggregate接口（集合）interface Aggregate &#123;12 public abstract Iterator iterator();&#125; 定义Iterator接口（迭代器）interface Iterator &#123;123public abstract boolean hasNext();public abstract Object next();&#125; 定义Book类class Book &#123;12345678private String name;public Book(String name) &#123; this.name = name;&#125;public String getName() &#123; return name;&#125;&#125; 定义BookSelf类（具体的集合）class BookShelf implements Aggregate &#123;1234567891011121314151617private ArrayList books; public BookShelf(int initialsize) &#123; this.books = new ArrayList(initialsize); &#125; public Book getBookAt(int index) &#123; return (Book)books.get(index); &#125;public void appendBook(Book book) &#123; books.add(book); &#125;public int getLength() &#123; return books.size(); &#125;public Iterator iterator() &#123; return new BookShelfIterator(this);&#125;&#125; 这里用了ArrayList来实现动态数组，避免当书本过多时而受到限制，有时间在分析ArrayList的源码 定义BookShelfIterator（具体的迭代器）class BookShelfIterator implements Iterator &#123;12345678910111213141516171819private BookShelf bookShelf;private int index;public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0;&#125;public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; else &#123; return false; &#125;&#125;public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book;&#125;&#125; 因为BookShelfIterator类要发挥Iterator的作用，so实现了Iterator的接口 UML图如下： 使用Iterator的作用引入Iterator模式后把遍历和实现分离开来，如下 (it.hasNext()) &#123;123 Book book = (Book)it.next(); System.out.println(book.getName());&#125; 这里只使用了Iterator的next和hasNext，并没有调用Bookshelf的方法，也就是说，这里的while循环并不依赖Bookshelf的实现。 如果Bookshelf的开发人员放弃ArrayList来管理书本，而是用vector来取而代之，不管Bookshelf如何变化，只要Bookshelf的iterator方法能够正确返回Iterator的实例，即使不对while的循环作任何修改，代码都可以正常工作。 如果只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。为了弱化类之间的耦合，进而使得类更加容易作为组件被再次利用，我们需要引入抽象类和接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫分析微信好友]]></title>
    <url>%2F2017%2F12%2F10%2Findex%2F</url>
    <content type="text"><![CDATA[昨晚了解到Python的itchat包，很强，已经完成了wechat的个人账号API接口，就可以用他来做很多数据分析的有趣事情了。首先引入各个包 itchat # itchat documentation -- https:/ itchat.readthedocs.io/zh/latest/api/1234567891011import matplotlib.pyplot as pltimport seaborn as snsimport numpy as npimport pandas as pdimport refrom wordcloud import WordCloud, ImageColorGeneratorimport PIL.Image as Image # pillowimport jieba # chinese word segementation toolfrom matplotlib.font_manager import FontProperties# since matplotlib and pandas.plot cannot display chinesefont = FontProperties(fname=&apos;./data/test.ttf&apos;, size=14) # load chinese font 引入包时遇到很多麻烦，首先很多包不支持3.7，然后我又下了个3.6的，应该把2.7的也下载，Python的版本啊~~~~ 我一般直接用Pycharm的直接下载，但到了wordcloud却不支持了，经过我不懈的查找，踩了很多坑，在stackOverflow查到了 download wordcloud‑1.3.2‑cp36‑cp36m‑win_amd64.whl from http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud Copy the file to your current working directory Open command prompt from Tools python -m pip install wordcloud-1.3.2-cp36-cp36m-win_amd64.whl 然后登陆网页版微信获取好友数据#login, default a QR code will be generated, scan for login itchat.login() friends = itchat.get_friends(update=True)[0:] # get all friends print(friends[0]) # the first one is yourself 扫描二维码来登陆即可对我好友的男女比例进行统计`male, female, others = get_male_female_count(friends[1:]) total = len(friends[1:]) print(&apos;Male population: {:d}, ratio: {:.4f}&apos;.format(male, male / float(total))) print(&apos;Female population: {:d}, ratio: {:.4f}&apos;.format(female, female / float(total))) print(&apos;Others: {:d}, ratio: {:.4f}&apos;.format(others, others / float(total)))` 函数： `def get_male_female_count(friends): male = 0 female = 0 others = 0 for friend in friends: sex = friend[&apos;Sex&apos;] if sex == 1: male += 1 elif sex == 2: female += 1 else: others += 1 return male, female, others` 用PIL画图 `# plot male-female-ratio index = np.arange(3) genders = (male, female, others) bar_width = 0.35 plt.figure(figsize=(14, 7)) plt.bar(index, genders, bar_width, alpha=0.6, color=&apos;rgb&apos;) plt.xlabel(&apos;Gender&apos;, fontsize=16) plt.ylabel(&apos;Population&apos;, fontsize=16) plt.title(&apos;Male-Female Population&apos;, fontsize=18) plt.xticks(index, (&apos;Male&apos;, &apos;Female&apos;, &apos;Others&apos;), fontsize=14, rotation=20) plt.ylim(0, 220) for idx, gender in zip(index, genders): plt.text(idx, gender + 0.1, &apos;%.0f&apos; % gender, ha=&apos;center&apos;, va=&apos;bottom&apos;, fontsize=14, color=&apos;black&apos;) plt.show()` 结果嘛为什么这么少呢，哦，好像前阵子删除了很多无联系的账号，重点是比例，ozx。 对好友城市的分布也做了分析`# extract the variables: NickName, Sex, City, Province, Signature def get_features(friends): features = [] for friend in friends: feature = {&apos;NickName&apos;: friend[&apos;NickName&apos;], &apos;Sex&apos;: friend[&apos;Sex&apos;], &apos;City&apos;: friend[&apos;City&apos;], &apos;Province&apos;: friend[&apos;Province&apos;], &apos;Signature&apos;: friend[&apos;Signature&apos;]} features.append(feature) return pd.DataFrame(features) features = get_features(friends[1:]) print(features.columns) features.head() locations = features.loc[:, [&apos;Province&apos;, &apos;City&apos;]] # get location columns locations = locations[locations[&apos;Province&apos;] != &apos;&apos;] # clean empty city or province records data = locations.groupby([&apos;Province&apos;, &apos;City&apos;]).size().unstack() # group by and count count_subset = data.take(data.sum(1).argsort())[-20:] # obtain the 20 highest data # plot subset_plot = count_subset.plot(kind=&apos;bar&apos;, stacked=True, figsize=(24, 24))` 结果都是广东的多，其他的几乎没有。 将好友的个性签名用wordcloud生成词云` set fonts xtick_labels = subset_plot.get_xticklabels() for label in xtick_labels: label.set_fontproperties(font) legend_labels = subset_plot.legend().texts for label in legend_labels: label.set_fontproperties(font) label.set_fontsize(10) plt.xlabel(&apos;Province&apos;, fontsize=20) plt.ylabel(&apos;Number&apos;, fontsize=20) plt.show() sigature_list = [] for signature in features[&apos;Signature&apos;]: signature = signature.strip().replace(&apos;span&apos;, &apos;&apos;).replace(&apos;class&apos;, &apos;&apos;).replace(&apos;emoji&apos;, &apos;&apos;) # re.compile(ur&apos;[^a-zA-Z0-9\u4e00-\u9fa5 ]&apos;).sub(&apos;&apos;, signature) signature = re.compile(&apos;1f\d+\w*|[&lt;&gt;/=]&apos;).sub(&apos;&apos;, signature) if (len(signature) &gt; 0): sigature_list.append(signature) text = &apos;&apos;.join(sigature_list) # print(text) word_list = jieba.cut(text, cut_all=True) words = &apos; &apos;.join(word_list) # print(words) coloring = np.array(Image.open(&apos;./data/wechat3.png&apos;)) wc = WordCloud(background_color=&apos;white&apos;, max_words=2000, mask=coloring, max_font_size=60, random_state=42, font_path=&apos;./data/test.ttf&apos;, scale=2).generate(words) image_color = ImageColorGenerator(coloring) plt.figure(figsize=(32, 16)) plt.imshow(wc.recolor(color_func=image_color)) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show()` 结果啊 我的好友还是很积极向上的，学习奋斗和努力还是有一定比例的，喜欢也可以理解，但为何生活人生世界这么大比例，ozx，这么多人看破尘世了？还是鸡汤看多了。 参考 https://github.com/amueller/word_cloud https://github.com/littlecodersh/ItChat http://www.36dsj.com/archives/88199 https://isaacchanghau.github.io/2017/09/10/Python-itchat%E5%8C%85%E5%88%86%E6%9E%90%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热度榜]]></title>
    <url>%2F2017%2F12%2F10%2Fpage%2F</url>
    <content type="text"><![CDATA[AV.initialize("", "");热度排行Top： var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) { for (var i=0;i]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 最近访客]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
