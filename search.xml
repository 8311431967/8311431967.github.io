<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对婚姻，楼市，资本，文化的一些看法]]></title>
    <url>%2F2018%2F08%2F04%2F%E5%AF%B9%E5%A9%9A%E5%A7%BB%EF%BC%8C%E6%A5%BC%E5%B8%82%EF%BC%8C%E8%B5%84%E6%9C%AC%EF%BC%8C%E6%96%87%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言近日发生的事情比较多，接触的信息也比较杂乱，思考也比较频繁，决定写一下当下感触。 婚姻的变迁从古代的拜堂成亲到现代的一夫一妻，恋爱和婚姻像其他文化一样，都是被塑造出来的社会关系。而一夫一妻制从某种程度上，保证屌丝也能也有娶上老婆的机会，但随着工业化，科技现代化的推进，结婚也成了一个人的累赘。听起以前我妈那个年代，彩礼也只是一头猪，到现在的车，房子的首付，甚至是房子。 知乎上有个有趣的提问，为什么男人越来越不想结婚，有个高票回答。男人觉得结婚吃亏所以不想结婚，女人也觉得结婚吃亏不想结婚，说明结婚内耗太大。 虚高的房价恋爱和婚姻是被塑造出来的一种社会关系，在资本的眼里，，就只能被资本改造和裹挟，成了绑架大众的工具。 资本先利用舆论把房价炒上天，然后告诉我们，没房没资格结婚。依靠着大众对婚姻的向往，逼迫年轻人掏空父母，用六个钱包，来接盘虚高的房价。我姐今年买房，首付不够，到处借钱，已经不止是六个钱包了，挤入了婚姻的门槛，却又过上了省吃俭用的生活。 仍旧是将婚姻和家庭作为人质，依靠着大众对婚姻和家庭的责任，资本逼迫着大众接受996，繁重而苦役的劳作。最后，到35岁的时候，资本还会将这些失去剥夺价值的劳工扫地出门，近来连续跳楼的中年程序员，给我敲响了警钟，要给自己留后路。 有能力接盘的被收割，而没有能力接盘，同样无法逃脱。在资本主导的舆论下，他们（可能就是我）要一辈子在社会的歧视下单独过活。更糟糕的是，现实里并不是看穿这场阴谋和骗局就能解决问题，钻石的营销手段广为人知，各种金融骗局的手段，也被暴露在阳光下，但人们看到了问题所在，却被利益驱使，主动迎合骗局，自愿地参与了这样的狂欢。 社会关系和观念的改造一旦完成，人们自发的成了体制的一部分，自发的维护着这个体系。 资本改造过后的婚姻婚姻和爱情已经被改造，大面积的表现出对资本的崇拜，对消费的依赖，对成员的绑架和裹挟。没钱不配结婚，没钱不配生孩子，没钱不配有家庭。 社会关系带给人们的痛苦，最终会驱使人们放弃社会关系。 发达国家广泛的不婚不育，慢性自杀，是生命自发的反抗。 日本和韩国的不婚率和不育率将是我国的未来。 结语什么人才会发这样的牢骚呢，对，就是我这样的穷人。老家的今年房价由于碧桂园的强势介入，上限已经突破了8000元/平方米(垃圾五线城市），哥又买了房，又刚生了小孩，两个小孩，吃力。而听师兄说他们认识的几个技术大牛，都没能留在一线城市，去了二三线城市，玩技术的终究是玩不过玩资本的，我又何去何从,怀疑人生。8/4/2018 1:18:12 AM]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>感触</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的反射]]></title>
    <url>%2F2018%2F05%2F24%2FJava%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射反射是动态加载对象，并对对象进行剖析。在运行状态中，对于任意的一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。 反射的基本操作获取类中的所有方法1234567891011121314151617181920212223242526272829303132public class Student &#123; private long id; private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static void main(String[] args) &#123; try &#123; Class&lt;?&gt; clz = Class.forName(&quot;reflect.Student&quot;); Method[] methods = clz.getMethods(); for (Method method : methods) &#123; System.out.println(&quot;方法名：&quot; + method.getName()); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Class.forName(“reflect.Student”)：初始化指定的类 clz。getMethods():获取勒种所有的方法 如果只需要获取加载类中的方法，不要父类的方法，可以使用下面的代码： `Method[] methods = clz.getDeclaredMethods();` Method是方法类，可以获取方法相关的信息，除了我们上面的方法名称，我们还可以获取其他的一些信息，比如： 方法返回类型：method.getReturnType().getName() 方法修饰符：Modifier.toString(method.getModifiers()) 方法参数信息： method.getParameters() 方法上的注解： method.getAnnotations() 等等……. 通过反射来调用方法12345678910try &#123; Class&lt;?&gt; clz = Class.forName(&quot;reflect.Student&quot;); Student stu = (Student) clz.newInstance(); System.out.println(stu.getName()); Method method = clz.getMethod(&quot;setName&quot;, String.class); method.invoke(stu, &quot;kun&quot;); System.out.println(stu.getName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 通过class的newInstance()方法构造一个Student对象，然后调用getName()方法，这个时候输出的是null,然后通过方法名获取到setName方法，通过invoke调用方法，传入参数，然后调用getName()方法可以看到输出的就是我们设置的值“kun”. 获取类中的所有属性12345Class&lt;?&gt; clz = Class.forName(&quot;reflect.Student&quot;);Field[] fields = clz.getFields();for (Field field : fields) &#123; System.out.println(&quot;属性名：&quot; + field.getName());&#125; clz.getFields()只能获取public的属性，包括父类的。 如果需要获取自己声明的各种字段，包括public，protected，private得用clz.getDeclaredFields() Field是属性类，可以获取属性相关的信息，比如： 属性类型：field.getType().getName() 属性修饰符：Modifier.toString(field.getModifiers()) 属性上的注解： field.getAnnotations() 等等……. 通过clz.getDeclaredField(“name”);获取name属性，调用get方法获取属性的值，第一次肯定是没有值的，然后调用set方法设置值，最后再次获取就有值了，在get之前有field.setAccessible(true);这个代码，如果不加的话就会报下面的错误信息： &apos;Class fs.Test can not access a member of class fs.Student with modifiers &quot;private&quot; &apos; setAccessible(true);以取消Java的权限控制检查，让我们在用反射时可以访问访问私有变量 反射的优缺点优点 反射提高了程序的灵活性和扩展性,在底层框架中用的比较多，业务层面的开发过程中尽量少用。 缺点： 性能不好 反射是一种解释操作,用于字段和方法接入时要远慢于直接代码，下面通过2段简单的代码来比较下执行的时间就可以体现出性能的问题 直接创建对象，时间787ms#### 12345678long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; Student stu = new Student(); stu.setName(&quot;kun&quot;); System.out.println(stu.getName()); &#125; long end = System.currentTimeMillis(); System.out.println(end - start); 利用反射来实现上面的功能，时间在2982ms左右，我是在我本机测试的#### 1234567891011121314long start1 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; try &#123; Class&lt;?&gt; clz = Class.forName(&quot;reflect.Student&quot;); Student stu = (Student) clz.newInstance(); Method method = clz.getMethod(&quot;setName&quot;, String.class); method.invoke(stu, &quot;kun&quot;); System.out.println(stu.getName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; long end1 = System.currentTimeMillis(); System.out.println(end1 - start1); 反射的使用场景 实现RPC框架 实现ORM框架 拷贝属性值（BeanUtils.copyProperties） …… 就先这样，又空再看一下相关源码。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2018%2F05%2F12%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题意：现在有一数组存放int型整数，数字有重复，且有一数字出现的频率超过了50%，请找出这个数字。 乍一看，这是个水题，但如何提高查找性能也是很有意思的。 方法一将数组排序，然后中间的数一定是要求的。排序最小的时间复杂度（快速排序）O(NlogN)，加上遍历。不过Jvm的sort也是很快的。 1234public int MoreHalf_1(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2]; &#125; 方法二用一个Map来存储，大于数组的一半就找到。这个方法的时间复杂度是O(N)，空间复杂度是O(n)。 123456789101112131415public int MoreHalf_2(int[] nums) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int i =0; for (;i &lt; nums.length; i++)&#123; if (map.containsKey(nums[i]))&#123; map.put(nums[i],map.get(nums[i])+1); if (map.get(nums[i]) &gt;=nums.length/2)&#123; break; &#125; &#125;else&#123; map.put(nums[i],1); &#125; &#125; return nums[i]; &#125; 方法三出现的次数超过数组长度的一半，表明这个数字出现的次数比其他数出现的次数的总和还多。 考虑每次删除两个不同的数，那么在剩下的数中，出现的次数仍然超过总数的一般，不断重复该过程，排除掉其他的数，最终找到那个出现次数超过一半的数字。这个方法的时间复杂度是O(N)，空间复杂度是O(1)。但删除开销大，可以用标记代替。 在遍历数组的过程中，保存两个值，一个是数组中数字，一个是出现次数。当遍历到下一个数字时，如果这个数字跟之前保存的数字相同，则次数加1，如果不同，则次数减1。如果次数为0，则保存下一个数字并把次数设置为1，由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。 1234567891011121314151617181920212223242526public int MoreHalf_3(int[] nums) &#123; int result = 0; int count = 1; if (nums.length == 0) return -1; result = nums[0]; for (int i = 1 ; i &lt; nums.length; i++)&#123; if (count==0)&#123; result = nums[i]; count = 1; continue; &#125; if (nums[i]==result)&#123; count++; &#125;else &#123; count--; &#125; &#125; count = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if(result == nums[i])count++; &#125; if(count &gt; nums.length/2) return result ; return 0; &#125; 方法四改进快排，利用Partition来确定index，然后mid比较，等于mid就找到了。（Partition确定的是index左边的数比nums[index]小，右边的数比nums[index]大） 12345678910111213141516171819202122232425262728293031323334353637public int MoreThanHalf_4(int[] nums)&#123; if(nums.length==0) return -1; int start = 0; int end = nums.length-1; int index = Partition(nums, start, end); int mid = nums.length/2; while(index!=mid)&#123; if(index&gt;mid) //如果调整数组以后获得的index大于middle，则继续调整start到index-1区段的数组 index = Partition(nums, start, index-1); else&#123; //否则调整index+1到end区段的数组 index = Partition(nums, index+1, end); &#125; &#125; return nums[index]; &#125; public int Partition(int[] nums,int start,int end)&#123; int pivotkey = nums[start]; int origin = start; while(start&lt;end)&#123; while(start&lt;end&amp;&amp;nums[end]&gt;=pivotkey) end--; while(start&lt;end&amp;&amp;nums[start]&lt;pivotkey) start++; swap(nums,start,end); &#125; swap(nums,start,end); swap(nums,origin,end); return end; &#125; public int[] swap(int[] ints, int x, int y) &#123; int temp = ints[x]; ints[x] = ints[y]; ints[y] = temp; return ints; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的四大特性以及隔离级别]]></title>
    <url>%2F2018%2F05%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[今天有空来了解一下数据的事务四大特性，以及它的隔离级别。下周线代考试，明天再复习吧。 事务的四大特性原子性（Atomicity) 原子性是指事务包含的操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果失败则不能对数据库有任何影响。 一致性（Consisitency) 一致性是指必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说完一个事务行之前和执行之后都必须处于一致性状态。 一个比较好的例子就是转账，假设用户A和用户B两者的前加起来一共是10000，那不管A和B之间如何转账，转多少次账，事务结束后两个用户的钱相加还是10000，这就是事务的一致性。 隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作干扰，多个并发的事务之间要相互隔离。 即要达到一种效果，对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束了，要么在T1结束后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 以上四大事务简称ACID 事务隔离级别Read uncommitted 读未提交 公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。 出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。 当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。 Read commited 读已提交 singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何…… 出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。 当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。 大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。 Repeat read 重复读 当隔离级别设置为Repeatable read时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。 虽然Repeatable read避免了不可重复读，但还有可能出现幻读。 singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。 注：Mysql的默认隔离级别就是Repeatable read。 Serializable 序列化Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays.sort和Collections.sort实现原理探究]]></title>
    <url>%2F2018%2F05%2F04%2FArrays-sort%E5%92%8CCollections-sort%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[前言一直对Arrays.sort()和Collections.sort()的有什么区别好奇，有时间就对源码分析一下。 Arrays.sort()先看Arrays.sort()，一进去是这样的。果然没有那么简单，DualPivotQuicksort翻译过来就是双轴快速排序，关于双轴排序可以去这里http://www.cnblogs.com/nullzx/p/5880191.html 看看。那再次点进去，可以发现有这么一段代码 1234if (right - left &lt; QUICKSORT_THRESHOLD) &#123; sort(a, left, right, true); return;&#125; 可以发现如果数组的长度小于QUICKSORT_THRESHOLD的话就会使用这个双轴快速排序，而这个值是286。 那如果大于286呢，它就会坚持数组的连续升序和连续降序性好不好，如果好的话就用归并排序，不好的话就用快速排序，看下面这段注释就可以看出 The array is not highly structured, use Quicksort instead of merge sort. 那现在再回到上面的决定用双轴快速排序的方法上，再点进去，发现又会多一条判断 // Use insertion sort on tiny arraysif (length &lt; INSERTION_SORT_THRESHOLD) 所以总结一下Arrays.sort()方法，如果数组长度大于等于286且连续性好的话，就用归并排序，如果大于等于286且连续性不好的话就用双轴快速排序。如果长度小于286且大于等于47的话就用双轴快速排序，如果长度小于47的话就用插入排序。 Collections.sort() Collections.sort()底层调用的是array.sort(). 写个demo跟踪下 ** 123456789101112public class TestSort &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = Arrays.asList(&quot;6&quot;, &quot;1&quot;, &quot;3&quot;, &quot;1&quot;,&quot;2&quot;); Collections.sort(strings);//sort方法在这里 for (String string : strings) &#123; System.out.println(string); &#125; &#125;&#125; 然后发现Collections.sort()调用的是list.sort() 而在list.sort()中调用了Arrays.sort() 然后发现里面调用的Arrays.sort(a, c); a是list,c是一个比较器，我们来看一下这个方法 由网上查得，LegacyMergeSort是一个老的归并排序，不过不用管了现在默认是关的。 我们走的是sort(a)这个方法，接着进入这个 5.最后就是TimSort()的源码了 12345678910111213141516171819202122232425262728293031323334353637383940414243static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // array的大小为0或者1就不用排了 // 当数组大小小于MIN_MERGE(32)的时候，就用一个&quot;mini-TimSort&quot;的方法排序，jdk1.7新加 if (nRemaining &lt; MIN_MERGE) &#123; //这个方法比较有意思，其实就是将我们最长的递减序列，找出来，然后倒过来 int initRunLen = countRunAndMakeAscending(a, lo, hi); //长度小于32的时候，是使用binarySort的 binarySort(a, lo, hi, lo + initRunLen); return; &#125; //先扫描一次array，找到已经排好的序列，然后再用刚才的mini-TimSort，然后合并，这就是TimSort的核心思想 ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen); int minRun = minRunLength(nRemaining); do &#123; // Identify next run int runLen = countRunAndMakeAscending(a, lo, hi); // If run is short, extend to min(minRun, nRemaining) if (runLen &lt; minRun) &#123; int force = nRemaining &lt;= minRun ? nRemaining : minRun; binarySort(a, lo, lo + force, lo + runLen); runLen = force; &#125; // Push run onto pending-run stack, and maybe merge ts.pushRun(lo, runLen); ts.mergeCollapse(); // Advance to find next run lo += runLen; nRemaining -= runLen; &#125; while (nRemaining != 0); // Merge all remaining runs to complete sort assert lo == hi; ts.mergeForceCollapse(); assert ts.stackSize == 1; &#125; TimSort的算法性能分析详见：https://blog.csdn.net/yangzhongblog/article/details/8184707]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Jdk源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架总结与分析(二)]]></title>
    <url>%2F2018%2F04%2F25%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E4%B8%8E%E5%88%86%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架总结与思考（一）]]></title>
    <url>%2F2018%2F04%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[前言对Java的集合框架用得比较频繁，但疏于总结，今天就从源码来分析一波。 集合框架（Collection Framework）首先要明确，集合代表了一组对象（和数组一样，但数组长度不能变，而集合能）。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。 先来整体来分析 简单说明 ： 集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 实现类：8个实现类（实线表示），对接口的具体实现。 Collection 接口是一组允许重复的对象。 Set 接口继承 Collection，集合元素不重复。 List 接口继承 Collection，允许重复，维护元素插入顺序。 Map接口是键－值对象，与Collection接口没有什么关系。 . Set 接口继承 Collection，集合元素不重复。 List 接口继承 Collection，允许重复，维护元素插入顺序。 Map接口是键－值对象，与Collection接口没有什么关系。 .Set、List和Map可以看做集合的三大类： List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 两大基类Collection与Map在集合框架的类继承体系中，最顶层有两个接口 Collection表示一组纯数据 Map表示一组key-value对 一般继承自Collection或Map的集合类，会提供两个“标准”的构造函数 没有参数的构造函数，创建一个空的集合类 有一个类型与基类（Collection或Map）相同的构造函数，创建一个与给定参数具有相同元素的新集合类Collection 如上图所示，Collection类主要有三个接口： Set表示不允许有重复元素的集合（A collection that contains no duplicate elements） List表示允许有重复元素的集合（An ordered collection (also known as a sequence)） Queue JDK1.5新增，与上面两个集合类主要是的区分在于Queue主要用于存储数据，而不是处理数据。（A collection designed for holding elements prior to processing.） Map 接口说明Collection接口除了Map接口，其他集合都是Collection的子类，并且在我们的实际编程中，由于多态的原因，我们一般都会使用这个的编码方式，如：Inter i1 = new ImplementInter();(其中，Inter表示一个接口，ImplementInter表示对此接口的实现)，此时i1调用的方法只能是Inter接口中的方法，无法调用ImplementInter中新增的方法（除非进行向下类型转化）。所以，很有必要了解一下Collection根接口中都有哪些方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); // jdk1.8添加的方法 default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) &#123; if (filter.test(each.next())) &#123; each.remove(); removed = true; &#125; &#125; return removed; &#125; @Override default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0); &#125; default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true); &#125;&#125; 其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。 另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。 Collection接口有两个常用的子接口，下面详细介绍。 1.List接口 List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。 List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 （1）ArrayList ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。 size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。 ArrayList擅长于随机访问。同时ArrayList是非同步的。 （2）LinkedList 同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：List list = Collections.synchronizedList(new LinkedList(…)); （3）Vector 与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 （4）Stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 2.Set接口 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。需要注意的是:虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。 此外需要说明一点，在set接口中的不重复是有特殊要求的。 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 （1）HashSet HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。 HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。 HashSet使用和理解中容易出现的误区: a.HashSet中存放null值 HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。 b.HashSet中存储元素的位置是固定的 HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。 c.必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 （2）LinkedHashSet LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。 （3）TreeSet TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。 其中在jdk1.8后添加的方法对我们的分析不会产生影响，添加的方法有关键字default修饰，为缺省方法，是一个新特性。 对集合而言，都会包含添加、删除、判断、清空、大小等基本操作。 Map接口对于Map接口而言，是键值对集合，特别适用于那种情形，一个主属性，另外一个副属性（如：姓名，性别；kr,男），添加元素时，若存在相同的键，则会用新值代替旧值。方法如下 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188public interface Map&lt;K,V&gt; &#123; int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); // jdk1.8 后添加的方法 public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey()); &#125; public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue()); &#125; public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey()); &#125; public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue()); &#125; &#125; boolean equals(Object o); int hashCode(); default V getOrDefault(Object key, V defaultValue) &#123; V v; return (((v = get(key)) != null) || containsKey(key))? v: defaultValue; &#125; default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Objects.requireNonNull(action); for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123; K k; V v; try &#123; k = entry.getKey(); v = entry.getValue(); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; action.accept(k, v); &#125; &#125; default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Objects.requireNonNull(function); for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123; K k; V v; try &#123; k = entry.getKey(); v = entry.getValue(); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; // ise thrown from function is not a cme. v = function.apply(k, v); try &#123; entry.setValue(v); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; &#125; &#125; default V putIfAbsent(K key, V value) &#123; V v = get(key); if (v == null) &#123; v = put(key, value); &#125; return v; &#125; default boolean remove(Object key, Object value) &#123; Object curValue = get(key); if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; remove(key); return true; &#125; default boolean replace(K key, V oldValue, V newValue) &#123; Object curValue = get(key); if (!Objects.equals(curValue, oldValue) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; put(key, newValue); return true; &#125; default V replace(K key, V value) &#123; V curValue; if (((curValue = get(key)) != null) || containsKey(key)) &#123; curValue = put(key, value); &#125; return curValue; &#125; default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; Objects.requireNonNull(mappingFunction); V v; if ((v = get(key)) == null) &#123; V newValue; if ((newValue = mappingFunction.apply(key)) != null) &#123; put(key, newValue); return newValue; &#125; &#125; return v; &#125; default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue; if ((oldValue = get(key)) != null) &#123; V newValue = remappingFunction.apply(key, oldValue); if (newValue != null) &#123; put(key, newValue); return newValue; &#125; else &#123; remove(key); return null; &#125; &#125; else &#123; return null; &#125; &#125; default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue = get(key); V newValue = remappingFunction.apply(key, oldValue); if (newValue == null) &#123; // delete mapping if (oldValue != null || containsKey(key)) &#123; // something to remove remove(key); return null; &#125; else &#123; // nothing to do. Leave things as they were. return null; &#125; &#125; else &#123; // add or replace old mapping put(key, newValue); return newValue; &#125; &#125; default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) &#123; remove(key); &#125; else &#123; put(key, newValue); &#125; return newValue; &#125;&#125; 1.HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 2.LinkedHashMap LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。 LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。 3.TreeMap TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。 自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。 定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。 TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。 如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。 简单说明： Map接口有一个内部接口Entry,对集合中的元素定义了一组通用的操作，维护这键值对，可以对键值对进行相应的操作，通过Map接口的entrySet可以返回集合对象的视图集，方便对集合对象进行遍历等操作。 对Map而言，也会包含添加、删除、判断、清空、大小等基本操作。]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之decorator模式]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8Bdecorator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言如果把程序中的对象比作蛋糕，然后想不断地向装饰蛋糕一样地不断地对其增加功能，它就变成了使用目的更加明确的对象。像这种不断为对象添加装饰的设计模式称之为decorator模式。 示例UML图 代码在https://github.com/8311431967/practiceCode Display类abstract class Display &#123;123456789 public abstract int getColumns(); // 获取横向字符数 public abstract int getRows(); // 获取纵向行数 public abstract String getRowText(int row); // 获取第row行的字符串 public void show() &#123; // 全部显示 for (int i = 0; i &lt; getRows(); i++) &#123; System.out.println(getRowText(i)); &#125; &#125;&#125; StringDisplay类用于显示单行字符串的类，肩负着实现Display类中的声明的抽象方法的重任。其相当于生日蛋糕中的核心蛋糕。 class StringDisplay extends Display &#123;123456789101112131415161718 private String string; // 要显示的字符串 public StringDisplay(String string) &#123; // 通过参数传入要显示的字符串 this.string = string; &#125; public int getColumns() &#123; // 字符数 return string.getBytes().length; &#125; public int getRows() &#123; // 行数是1 return 1; &#125; public String getRowText(int row) &#123; // 仅当row为0时返回值 if (row == 0) &#123; return string; &#125; else &#123; return null; &#125; &#125;&#125; Border作为装饰边框的抽象类 abstract class Border extends Display &#123;12345 protected Display display; // 表示被装饰物 protected Border(Display display) &#123; // 在生成实例时通过参数指定被装饰物 this.display = display; &#125;&#125; SideBorder类在两侧在上”|” class SideBorder extends Border &#123;123456789101112131415 private char borderChar; // 表示装饰边框的字符 public SideBorder(Display display, char ch) &#123; // 通过构造函数指定Display和装饰边框字符 super(display); this.borderChar = ch; &#125; public int getColumns() &#123; // 字符数为字符串字符数加上两侧边框字符数 return 1 + display.getColumns() + 1; &#125; public int getRows() &#123; // 行数即被装饰物的行数 return display.getRows(); &#125; public String getRowText(int row) &#123; // 指定的那一行的字符串为被装饰物的字符串加上两侧的边框的字符 return borderChar + display.getRowText(row) + borderChar; &#125;&#125; FullBorder类添加上下左右边框 class FullBorder extends Border &#123;1234567891011121314151617181920212223242526 public FullBorder(Display display) &#123; super(display); &#125; public int getColumns() &#123; // 字符数为被装饰物的字符数加上两侧边框字符数 return 1 + display.getColumns() + 1; &#125; public int getRows() &#123; // 行数为被装饰物的行数加上上下边框的行数 return 1 + display.getRows() + 1; &#125; public String getRowText(int row) &#123; // 指定的那一行的字符串 if (row == 0) &#123; // 上边框 return &quot;+&quot; + makeLine(&apos;-&apos;, display.getColumns()) + &quot;+&quot;; &#125; else if (row == display.getRows() + 1) &#123; // 下边框 return &quot;+&quot; + makeLine(&apos;-&apos;, display.getColumns()) + &quot;+&quot;; &#125; else &#123; // 其他边框 return &quot;|&quot; + display.getRowText(row - 1) + &quot;|&quot;; &#125; &#125; private String makeLine(char ch, int count) &#123; // 生成一个重复count次字符ch的字符串 StringBuffer buf = new StringBuffer(); for (int i = 0; i &lt; count; i++) &#123; buf.append(ch); &#125; return buf.toString(); &#125;&#125; Main类class Main &#123;123456789101112131415161718192021222324 public static void main(String[] args) &#123; Display b1 = new StringDisplay(&quot;Hello, world.&quot;); Display b2 = new SideBorder(b1, &apos;#&apos;); Display b3 = new FullBorder(b2); b1.show(); b2.show(); b3.show(); Display b4 = new SideBorder( new FullBorder( new FullBorder( new SideBorder( new FullBorder( new StringDisplay(&quot;你好，世界。&quot;) ), &apos;*&apos; ) ) ), &apos;/&apos; ); b4.show(); &#125;&#125; 结果如下： 要点接口的透明性1.在decorator模式中，装饰边框和装饰物具有一致性，也就是说Border类（及其子类）与表示被装饰物的Display类具有相同的接口。这样即使被装饰物被边框装饰起来，接口API也不会被隐藏起来，其他类依然可以调用getColumn(),getRows(),show()方法，这就是API接口的“透明性”。 2.得益于接口的透明化，Decorator模式中形成了类似Composite模式中的递归结构，装饰边框里面的被装饰物实际上又是别的物体的“装饰边框”。 在不改变被装饰物的前提下增加功能虽然接口是相同的，但是越装饰，功能则越多，eg，用sideborder装饰display后，在字符串两侧可以加上装饰字符，也可在加上FullBorder。此时，我们完全不需要对被装饰的类做任何修改。 decorator模式中使用了委托，它使类之间形成弱关联关系，因此不必改变框架代码，就可以生成一个与其他对象具有不同关系的新对象。 Java.io包与Decorator模式首先如读取文件的示例：Reader reader = new FileReader(“datafile.txt”); 然后我们可以向下面这样在读取文件时将文件内容放入缓冲区中。 Reader reader = new BufferReader(new FileReader(“data.txt”)); 还可以Reader reader = new LineNumberReader(new BufferReader(new FileReader(“data.txt”))); 无论是LineNumReader类的构造函数还是BufferedReader类的构造函数，都可以接受Reader类（子类）的实例作为参数，因此我们可以像上面那样自由的进行各种自由组合。 缺点导致程序中增加许多功能类似的很小的类，Java.io包的类我就还没记完，orz。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之抽象工厂模式]]></title>
    <url>%2F2018%2F04%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式抽象工厂的工作就是将抽象零件组装为抽象产品，也就是我们并不关心零件的具体实现，而是只关心接口（API）。 示例抽象的零件：Item类abstract class Item &#123;123456 protected String caption; public Item(String caption) &#123; this.caption = caption; &#125; public abstract String makeHTML();//抽象方法由子类实现&#125; 抽象的零件：Link类abstract class Link extends Item &#123;123456 protected String url; public Link(String caption, String url) &#123; super(caption); this.url = url; &#125;&#125; 抽象的零件：Tray类abstract class Tray extends Item &#123;12345678 protected ArrayList tray = new ArrayList(); public Tray(String caption) &#123; super(caption); &#125; public void add(Item item) &#123; tray.add(item); &#125;&#125; 抽象的产品：Page类abstract class Page &#123;1234567891011121314151617181920212223 protected String title; protected String author; protected ArrayList content = new ArrayList(); public Page(String title, String author) &#123; this.title = title; this.author = author; &#125; public void add(Item item) &#123; content.add(item); &#125; public void output() &#123; try &#123; String filename = title + &quot;.html&quot;; Writer writer = new FileWriter(filename); writer.write(this.makeHTML()); writer.close(); System.out.println(filename + &quot; 编写完成。&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public abstract String makeHTML();&#125; 抽象的工厂：Factory类getFactory()通过调用Class类的forName方法动态地读取类信息，接着用newInstance方法生成该类的实例，并将其作为返回值返回调用者。 请注意：虽然getFactory()方法生成的是具体工厂的实例，但是返回值是抽象工厂类型的。 abstract class Factory &#123;123456789101112131415 public static Factory getFactory(String classname) &#123; Factory factory = null; try &#123; factory = (Factory)Class.forName(classname).newInstance(); &#125; catch (ClassNotFoundException e) &#123; System.err.println(&quot;没有找到 &quot; + classname + &quot;类。&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return factory; &#125; public abstract Link createLink(String caption, String url); public abstract Tray createTray(String caption); public abstract Page createPage(String title, String author);&#125; 具体的工厂：ListFactory类class ListFactory extends Factory &#123;12345678910 public Link createLink(String caption, String url) &#123; return new ListLink(caption, url); &#125; public Tray createTray(String caption) &#123; return new ListTray(caption); &#125; public Page createPage(String title, String author) &#123; return new ListPage(title, author); &#125;&#125; 具体的零件：ListLink类class ListLink extends Link &#123;1234567 public ListLink(String caption, String url) &#123; super(caption, url); &#125; public String makeHTML() &#123; return &quot; &lt;li&gt;&lt;a href=\&quot;&quot; + url + &quot;\&quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&lt;/li&gt;\n&quot;; &#125;&#125; 具体的零件：ListTray类划重点：通过使用迭代器，调用Item的makeHTML()，请注意，这里并不关心变量Item中保存的实例究竟是ListLink的实例还是ListTray的实例，只是简单的调用makeHTML(),之后item会帮我们处理，这是面向对象编程的好处。 class ListTray extends Tray &#123;123456789101112131415161718 public ListTray(String caption) &#123; super(caption); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append(&quot;&lt;li&gt;\n&quot;); buffer.append(caption + &quot;\n&quot;); buffer.append(&quot;&lt;ul&gt;\n&quot;); Iterator it = tray.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append(&quot;&lt;/ul&gt;\n&quot;); buffer.append(&quot;&lt;/li&gt;\n&quot;); return buffer.toString(); &#125;&#125; 具体的产品：ListPage类class ListPage extends Page &#123;1234567891011121314151617181920 public ListPage(String title, String author) &#123; super(title, author); &#125; public String makeHTML() &#123; StringBuffer buffer = new StringBuffer(); buffer.append(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot; + title + &quot;&lt;/title&gt;&lt;/head&gt;\n&quot;); buffer.append(&quot;&lt;body&gt;\n&quot;); buffer.append(&quot;&lt;h1&gt;&quot; + title + &quot;&lt;/h1&gt;\n&quot;); buffer.append(&quot;&lt;ul&gt;\n&quot;); Iterator it = content.iterator(); while (it.hasNext()) &#123; Item item = (Item)it.next(); buffer.append(item.makeHTML()); &#125; buffer.append(&quot;&lt;/ul&gt;\n&quot;); buffer.append(&quot;&lt;hr&gt;&lt;address&gt;&quot; + author + &quot;&lt;/address&gt;&quot;); buffer.append(&quot;&lt;/body&gt;&lt;/html&gt;\n&quot;); return buffer.toString(); &#125;&#125; 使用工厂将零件组装成为产品：Main类该类只是引入了factory包，并没有使用任何具体的零件，产品和工厂 class Main &#123;12345678910111213141516171819202122232425262728293031323334353637 public static void main(String[] args) &#123; if (args.length != 1) &#123; System.out.println(&quot;Usage: java Main class.name.of.ConcreteFactory&quot;); System.out.println(&quot;Example 1: java Main listfactory.ListFactory&quot;); System.out.println(&quot;Example 2: java Main tablefactory.TableFactory&quot;); System.exit(0); &#125; // Factory factory = Factory.getFactory(&quot;abstractFactory.listfactory.ListFactory&quot;); Factory factory = Factory.getFactory(args[0]); Link people = factory.createLink(&quot;People Daily&quot;, &quot;http://www.people.com.cn/&quot;); Link gmw = factory.createLink(&quot;GuangMing Daily&quot;, &quot;http://www.gmw.cn/&quot;); Link us_yahoo = factory.createLink(&quot;Yahoo!&quot;, &quot;http://www.yahoo.com/&quot;); Link jp_yahoo = factory.createLink(&quot;Yahoo!Japan&quot;, &quot;http://www.yahoo.co.jp/&quot;); Link excite = factory.createLink(&quot;Excite&quot;, &quot;http://www.excite.com/&quot;); Link google = factory.createLink(&quot;Google&quot;, &quot;http://www.google.com/&quot;); Tray traynews = factory.createTray(&quot;NewsPaper&quot;); traynews.add(people); traynews.add(gmw); Tray trayyahoo = factory.createTray(&quot;Yahoo!&quot;); trayyahoo.add(us_yahoo); trayyahoo.add(jp_yahoo); Tray traysearch = factory.createTray(&quot;searchEngine&quot;); traysearch.add(trayyahoo); traysearch.add(excite); traysearch.add(google); Page page = factory.createPage(&quot;LinkPage&quot;, &quot;kr&quot;); page.add(traynews); page.add(traysearch); page.output(); &#125;&#125; 抽象工厂的优劣点####易于增加具体的工厂 这里说的容易是指需要编写哪些类和需要实现哪些方法都非常清楚。假设我们要在示例中增加新的具体工厂，那么需要做的就是编写Factory，Link，Tray，Page这四个类的子类，并实现他们定义的抽象方法。这样一来，无论要增加多少个具体工厂（或者是修改具体工厂的BUG），都无需修改抽象工厂。 ####难于增加新的零件 如果要增加新的零件时，就必须要对所有的具体工厂进行相应的修改。例如要在factory包中增加一个表示图像的Picture零件，就要在listfactory中作如下修改： 在ListFactory中加入createPicture； 新增ListPicture类 而且编写完成的具体工厂越多，修改的工作量越多。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式 抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对抖音和快手的体验与分析]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%AF%B9%E6%8A%96%E9%9F%B3%E5%92%8C%E5%BF%AB%E6%89%8B%E7%9A%84%E4%BD%93%E9%AA%8C%E4%B8%8E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[序言虽然以前就听过快手和抖音了，但好似对我的作用不大，就一直没有上手。But，快手和抖音都在2018的春节期间大放异彩，逐步占领市场。还有看到了中央颁布的互联网独角兽公司，我惊奇地发现快手竟然排到了61，而抖音也是有前一百的，被学生党喜闻乐见的知乎排在了110+。果然人民群众相对于.txt,.jpg,更喜欢*.avi啊。所以决定下载抖音和快手，来体验一下，顺便来为我拓宽一下设计思路。 界面和交互设计抖音的界面初始只有一个视频，不用点击就自动播放，双击点赞，上下滑下一个视频，很简单方便，但可选率低。而快手初始界面四张图片，需要点击进去才能播放，下滑可以看更多的缩略图。抖音的设计必须依靠强大的推荐系统，不然滑了几个视频都是不好看的就gg了。 推荐系统和算法毕竟一开始还是要给三无用户作推荐，大概是推荐点赞比较多的和关注度比较高的大v吧。而抖音请了明星入驻，一点开的都是明星的视频，而快手更多的是妹纸的，不过标题真的太太太尴尬了。那么如何给新用户增加曝光机会呢？ 在视频推荐中会穿插一些新用户的视频，我的观察大概是10条有1条。这样保证了在用户不会觉得烦的同时，也给了新的创作者一定流量。当新的视频达到一定的赞后，可能会被推送更多用户，而没有达到某个标准的视频可能会“进入冷宫“。这样的设计防止了像微博这类网站的大V把持流量所造成的马太效应，越来越多的平台在采取相同的策略 这样就能吸引新用户，增加优质资源的同时防止大v的流量劫持。 内容抖音的内容还算是积极向上，明星们都比较接地气，而且配上特定的BGM真的很魔性，还有一些人拍的情景剧，也就十秒左右，后来发现还是续集来的，orz。 而快手的内容就比较接地气，或者是少部分人说的俗，视频里主要是妹子跳舞，泳装…..还有农村里面的奇人异事，工厂妹的一天之类的。我觉得快手是切入点很准，面向二线三线四线的人，得屌丝者得天下啊。 不过上一次的十四岁怀孕少女的视频引起了人们的关注，进而对快手的鄙视，我还在live中发现了色情引流，虽然说可以举报，但管理员根本忙不过来啊。 监管这一方面还要加强吧，感觉要变成直播软件了。共青团入驻快手和抖音，我还特意搜了账号看作品，作品量低啊。 推荐广告这种流量软件当然少不了广告的，不然怎生存，穿插于视频中，用户不仔细看可能就已经当成一个普通视频看完了。我刚注册，广告遇见率不高，可能还是杀熟吧。再者听说抖音和快手的广告费是比知乎高几倍的，果然还是学生党比屌丝更穷啊。 结语抖音和快手的界面和交互设计都做得很好，也很快（只是我的辣鸡校园网不给力），智能推荐也很好，但过于沉溺于某个方面就会错过外面精彩的世界。就好像快手现在就只推荐都是妹纸的视频给我了，明明我本意是用快手和抖音记单词的。我觉得俗或不俗都是人民群众说了算，快手和抖音都是一个成功的app，既满足了人民的需求也从中捞到了利益。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Iterator模式]]></title>
    <url>%2F2018%2F04%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BIterator%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Iterator模式刚看完23种设计模式，就先来总结一下Iterator模式。重点是掌握使用抽象类和接口来编程。先来回忆一下这个例子： 定义Aggregate接口（集合）interface Aggregate &#123;12 public abstract Iterator iterator();&#125; 定义Iterator接口（迭代器）interface Iterator &#123;123public abstract boolean hasNext();public abstract Object next();&#125; 定义Book类class Book &#123;12345678private String name;public Book(String name) &#123; this.name = name;&#125;public String getName() &#123; return name;&#125;&#125; 定义BookSelf类（具体的集合）class BookShelf implements Aggregate &#123;1234567891011121314151617private ArrayList books; public BookShelf(int initialsize) &#123; this.books = new ArrayList(initialsize); &#125; public Book getBookAt(int index) &#123; return (Book)books.get(index); &#125;public void appendBook(Book book) &#123; books.add(book); &#125;public int getLength() &#123; return books.size(); &#125;public Iterator iterator() &#123; return new BookShelfIterator(this);&#125;&#125; 这里用了ArrayList来实现动态数组，避免当书本过多时而受到限制，有时间在分析ArrayList的源码 定义BookShelfIterator（具体的迭代器）class BookShelfIterator implements Iterator &#123;12345678910111213141516171819private BookShelf bookShelf;private int index;public BookShelfIterator(BookShelf bookShelf) &#123; this.bookShelf = bookShelf; this.index = 0;&#125;public boolean hasNext() &#123; if (index &lt; bookShelf.getLength()) &#123; return true; &#125; else &#123; return false; &#125;&#125;public Object next() &#123; Book book = bookShelf.getBookAt(index); index++; return book;&#125;&#125; 因为BookShelfIterator类要发挥Iterator的作用，so实现了Iterator的接口 UML图如下： 使用Iterator的作用引入Iterator模式后把遍历和实现分离开来，如下 (it.hasNext()) &#123;123 Book book = (Book)it.next(); System.out.println(book.getName());&#125; 这里只使用了Iterator的next和hasNext，并没有调用Bookshelf的方法，也就是说，这里的while循环并不依赖Bookshelf的实现。 如果Bookshelf的开发人员放弃ArrayList来管理书本，而是用vector来取而代之，不管Bookshelf如何变化，只要Bookshelf的iterator方法能够正确返回Iterator的实例，即使不对while的循环作任何修改，代码都可以正常工作。 如果只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。为了弱化类之间的耦合，进而使得类更加容易作为组件被再次利用，我们需要引入抽象类和接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫分析微信好友]]></title>
    <url>%2F2017%2F12%2F10%2Findex%2F</url>
    <content type="text"><![CDATA[昨晚了解到Python的itchat包，很强，已经完成了wechat的个人账号API接口，就可以用他来做很多数据分析的有趣事情了。首先引入各个包 itchat # itchat documentation -- https:/ itchat.readthedocs.io/zh/latest/api/1234567891011import matplotlib.pyplot as pltimport seaborn as snsimport numpy as npimport pandas as pdimport refrom wordcloud import WordCloud, ImageColorGeneratorimport PIL.Image as Image # pillowimport jieba # chinese word segementation toolfrom matplotlib.font_manager import FontProperties# since matplotlib and pandas.plot cannot display chinesefont = FontProperties(fname=&apos;./data/test.ttf&apos;, size=14) # load chinese font 引入包时遇到很多麻烦，首先很多包不支持3.7，然后我又下了个3.6的，应该把2.7的也下载，Python的版本啊~~~~ 我一般直接用Pycharm的直接下载，但到了wordcloud却不支持了，经过我不懈的查找，踩了很多坑，在stackOverflow查到了 download wordcloud‑1.3.2‑cp36‑cp36m‑win_amd64.whl from http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud Copy the file to your current working directory Open command prompt from Tools python -m pip install wordcloud-1.3.2-cp36-cp36m-win_amd64.whl 然后登陆网页版微信获取好友数据#login, default a QR code will be generated, scan for login itchat.login() friends = itchat.get_friends(update=True)[0:] # get all friends print(friends[0]) # the first one is yourself 扫描二维码来登陆即可对我好友的男女比例进行统计`male, female, others = get_male_female_count(friends[1:]) total = len(friends[1:]) print(&apos;Male population: {:d}, ratio: {:.4f}&apos;.format(male, male / float(total))) print(&apos;Female population: {:d}, ratio: {:.4f}&apos;.format(female, female / float(total))) print(&apos;Others: {:d}, ratio: {:.4f}&apos;.format(others, others / float(total)))` 函数： `def get_male_female_count(friends): male = 0 female = 0 others = 0 for friend in friends: sex = friend[&apos;Sex&apos;] if sex == 1: male += 1 elif sex == 2: female += 1 else: others += 1 return male, female, others` 用PIL画图 `# plot male-female-ratio index = np.arange(3) genders = (male, female, others) bar_width = 0.35 plt.figure(figsize=(14, 7)) plt.bar(index, genders, bar_width, alpha=0.6, color=&apos;rgb&apos;) plt.xlabel(&apos;Gender&apos;, fontsize=16) plt.ylabel(&apos;Population&apos;, fontsize=16) plt.title(&apos;Male-Female Population&apos;, fontsize=18) plt.xticks(index, (&apos;Male&apos;, &apos;Female&apos;, &apos;Others&apos;), fontsize=14, rotation=20) plt.ylim(0, 220) for idx, gender in zip(index, genders): plt.text(idx, gender + 0.1, &apos;%.0f&apos; % gender, ha=&apos;center&apos;, va=&apos;bottom&apos;, fontsize=14, color=&apos;black&apos;) plt.show()` 结果嘛为什么这么少呢，哦，好像前阵子删除了很多无联系的账号，重点是比例，ozx。 对好友城市的分布也做了分析`# extract the variables: NickName, Sex, City, Province, Signature def get_features(friends): features = [] for friend in friends: feature = {&apos;NickName&apos;: friend[&apos;NickName&apos;], &apos;Sex&apos;: friend[&apos;Sex&apos;], &apos;City&apos;: friend[&apos;City&apos;], &apos;Province&apos;: friend[&apos;Province&apos;], &apos;Signature&apos;: friend[&apos;Signature&apos;]} features.append(feature) return pd.DataFrame(features) features = get_features(friends[1:]) print(features.columns) features.head() locations = features.loc[:, [&apos;Province&apos;, &apos;City&apos;]] # get location columns locations = locations[locations[&apos;Province&apos;] != &apos;&apos;] # clean empty city or province records data = locations.groupby([&apos;Province&apos;, &apos;City&apos;]).size().unstack() # group by and count count_subset = data.take(data.sum(1).argsort())[-20:] # obtain the 20 highest data # plot subset_plot = count_subset.plot(kind=&apos;bar&apos;, stacked=True, figsize=(24, 24))` 结果都是广东的多，其他的几乎没有。 将好友的个性签名用wordcloud生成词云` set fonts xtick_labels = subset_plot.get_xticklabels() for label in xtick_labels: label.set_fontproperties(font) legend_labels = subset_plot.legend().texts for label in legend_labels: label.set_fontproperties(font) label.set_fontsize(10) plt.xlabel(&apos;Province&apos;, fontsize=20) plt.ylabel(&apos;Number&apos;, fontsize=20) plt.show() sigature_list = [] for signature in features[&apos;Signature&apos;]: signature = signature.strip().replace(&apos;span&apos;, &apos;&apos;).replace(&apos;class&apos;, &apos;&apos;).replace(&apos;emoji&apos;, &apos;&apos;) # re.compile(ur&apos;[^a-zA-Z0-9\u4e00-\u9fa5 ]&apos;).sub(&apos;&apos;, signature) signature = re.compile(&apos;1f\d+\w*|[&lt;&gt;/=]&apos;).sub(&apos;&apos;, signature) if (len(signature) &gt; 0): sigature_list.append(signature) text = &apos;&apos;.join(sigature_list) # print(text) word_list = jieba.cut(text, cut_all=True) words = &apos; &apos;.join(word_list) # print(words) coloring = np.array(Image.open(&apos;./data/wechat3.png&apos;)) wc = WordCloud(background_color=&apos;white&apos;, max_words=2000, mask=coloring, max_font_size=60, random_state=42, font_path=&apos;./data/test.ttf&apos;, scale=2).generate(words) image_color = ImageColorGenerator(coloring) plt.figure(figsize=(32, 16)) plt.imshow(wc.recolor(color_func=image_color)) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show()` 结果啊 我的好友还是很积极向上的，学习奋斗和努力还是有一定比例的，喜欢也可以理解，但为何生活人生世界这么大比例，ozx，这么多人看破尘世了？还是鸡汤看多了。 参考 https://github.com/amueller/word_cloud https://github.com/littlecodersh/ItChat http://www.36dsj.com/archives/88199 https://isaacchanghau.github.io/2017/09/10/Python-itchat%E5%8C%85%E5%88%86%E6%9E%90%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热度榜]]></title>
    <url>%2F2017%2F12%2F10%2Fpage%2F</url>
    <content type="text"><![CDATA[AV.initialize("", "");热度排行Top： var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) { for (var i=0;i]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[优秀的人，不是不合群，而是他们合群的人里面没有你Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 最近访客]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
</search>
