<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="tree," />










<meta name="description" content="前言对leetcode上树的题解的总结。 树的高度public int maxDepth(TreeNode root) {     if (root == null) return 0;     return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } 平衡树   3    / \   9  20    /   \   15">
<meta name="keywords" content="tree">
<meta property="og:type" content="article">
<meta property="og:title" content="树">
<meta property="og:url" content="http://yoursite.com/2019/05/29/树/index.html">
<meta property="og:site_name" content="Kunrong-blog">
<meta property="og:description" content="前言对leetcode上树的题解的总结。 树的高度public int maxDepth(TreeNode root) {     if (root == null) return 0;     return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } 平衡树   3    / \   9  20    /   \   15">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-29T15:35:59.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="树">
<meta name="twitter:description" content="前言对leetcode上树的题解的总结。 树的高度public int maxDepth(TreeNode root) {     if (root == null) return 0;     return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } 平衡树   3    / \   9  20    /   \   15">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"left"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/29/树/"/>





  <title>树 | Kunrong-blog</title>
  








</head>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<!-- 背景动画 -->
<script type="text/javascript" src="/js/src/particle.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kunrong-blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于作者
          </a>
        </li>
      
        
        <li class="menu-item menu-item-secweb">
          <a href="/Secweb/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            导航
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      

      <li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
    function c() {
        var e = document.createElement("link");
        e.setAttribute("type", "text/css");
        e.setAttribute("rel", "stylesheet");
        e.setAttribute("href", f);
        e.setAttribute("class", l);
        document.body.appendChild(e)
    }
    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t < e.length; t++) {
            document.body.removeChild(e[t])
        }
    }
    function p() {
        var e = document.createElement("div");
        e.setAttribute("class", a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }
    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }
    function v(i) {
        var s = d(i);
        return s.height > e && s.height < n && s.width > t && s.width < r
    }
    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }
    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e && !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }
    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }
    function E(e) {
        var t = m(e);
        return t >= w && t <= b + w
    }
    function S() {
        var e = document.createElement("audio");
        e.setAttribute("class", l);
        e.src = i;
        e.loop = false;
        e.addEventListener("canplay", function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e < O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener("ended", function() {
            N();
            h()
        }, true);
        e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
        document.body.appendChild(e);
        e.play()
    }
    function x(e) {
        e.className += " " + s + " " + o
    }
    function T(e) {
        e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
    }
    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp("\\b" + s + "\\b");
        for (var n = 0; n < e.length; ) {
            e[n].className = e[n].className.replace(t, "")
        }
    }
    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3";
    var s = "mw-harlem_shake_me";
    var o = "im_first";
    var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
    var a = "mw-strobe_light";
    var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
    var l = "mw_added_css";
    var b = g();
    var w = y();
    var C = document.getElementsByTagName("*");
    var k = null;
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn("Could not find a node of the right size. Please try a different page.");
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
    })()    '></a> </li>
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kunrong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload_image/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kunrong-blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">树</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T12:27:39+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对leetcode上树的题解的总结。</p>
<h1 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h1><pre><code>public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre><h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><p>   3</p>
<p>   / \</p>
<p>  9  20</p>
<p>   /   \</p>
<p>  15   7</p>
<p>平衡树左右子树高度差都小于等于 1</p>
<pre><code>private boolean result = true;

public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) &gt; 1) result = false;
    return 1 + Math.max(l, r);
}
</code></pre><h1 id="两节点的最长路径"><a href="#两节点的最长路径" class="headerlink" title="两节点的最长路径"></a>两节点的最长路径</h1><pre><code>private int max = 0;

public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}
</code></pre><h1 id="翻转树"><a href="#翻转树" class="headerlink" title="翻转树"></a>翻转树</h1><pre><code>public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode left = root.left;  // 后面的操作会改变 left 指针，因此先保存下来
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
}
</code></pre><h1 id="归并两棵树"><a href="#归并两棵树" class="headerlink" title="归并两棵树"></a>归并两棵树</h1><pre><code>Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7

Output:
         3
        / \
       4   5
      / \   \
     5   4   7

public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return null;
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}
</code></pre><h1 id="判断路径和是否等于一个数"><a href="#判断路径和是否等于一个数" class="headerlink" title="判断路径和是否等于一个数"></a>判断路径和是否等于一个数</h1><p>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<p>路径和定义为从 root 到 leaf 的所有节点的和。</p>
<p>巧妙运用逆向思维，用sum减去遍历过的node</p>
<pre><code>public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
</code></pre><h1 id="统计路径和等于一个数的路径数量"><a href="#统计路径和等于一个数的路径数量" class="headerlink" title="统计路径和等于一个数的路径数量"></a>统计路径和等于一个数的路径数量</h1><pre><code>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre><p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p>
<p>其实这题和上一题的区别是在于不一定以root开头，所以开始的时候就分成三份，root，root.left,root.right</p>
<pre><code>public int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
}

private int pathSumStartWithRoot(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = 0;
    if (root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
}
</code></pre><h1 id="是否包含子树"><a href="#是否包含子树" class="headerlink" title="是否包含子树"></a>是否包含子树</h1><pre><code>Given tree s:
     3
    / \
   4   5
  / \
 1   2

Given tree t:
   4
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:
   4
  / \
 1   2

Return false.
</code></pre><p>其实就是遍历比较，相同就继续左左右右，不同就返回false，其中一个为null就false，只有同时为null才返回true</p>
<pre><code>public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
    if (t == null &amp;&amp; s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);
}
</code></pre><h1 id="镜像树"><a href="#镜像树" class="headerlink" title="镜像树"></a>镜像树</h1><pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>没什么好说的，就是左右对调比较。</p>
<pre><code>public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);
}
</code></pre><h1 id="最小路径"><a href="#最小路径" class="headerlink" title="最小路径"></a>最小路径</h1><p>树的根节点到叶子节点的最小路径长度</p>
<p>和最大深度差不多，只是这里是当left或right的深度为0时，返回和+1。</p>
<pre><code>public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
}
</code></pre><h1 id="返回左叶子节点的和"><a href="#返回左叶子节点的和" class="headerlink" title="返回左叶子节点的和"></a>返回左叶子节点的和</h1><pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<p>简单来说，先判断该节点的左节点是否叶子节点，是就返回val和sumof(root.right)。 不是就继续寻找，sumof(root.left)+sumof(root.right).</p>
<pre><code>public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) return 0;
    if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}

private boolean isLeaf(TreeNode node){
    if (node == null) return false;
    return node.left == null &amp;&amp; node.right == null;
}
</code></pre><h1 id="间隔遍历"><a href="#间隔遍历" class="headerlink" title="间隔遍历"></a>间隔遍历</h1><pre><code>    3
 / \
2   3
 \   \
  3   1
</code></pre><p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p>
<p>其实这题就是比较偷当前的和不偷当前的值。</p>
<pre><code>public int rob(TreeNode root) {
    if (root == null) return 0;
    int val1 = root.val;
    if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
    if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
    int val2 = rob(root.left) + rob(root.right);
    return Math.max(val1, val2);
}
</code></pre><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<h1 id="一棵树每层节点的平均数"><a href="#一棵树每层节点的平均数" class="headerlink" title="一棵树每层节点的平均数"></a>一棵树每层节点的平均数</h1><pre><code>public List&lt;Double&gt; averageOfLevels(TreeNode root) {
    List&lt;Double&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        double sum = 0;
        for (int i = 0; i &lt; cnt; i++) {
            TreeNode node = queue.poll();
            sum += node.val;
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(sum / cnt);
    }
    return ret;
}
</code></pre><h1 id="得到左下角的节点"><a href="#得到左下角的节点" class="headerlink" title="得到左下角的节点"></a>得到左下角的节点</h1><p>Input:</p>
<pre><code>    1
   / \
  2   3
 /   / \
4   5   6
   /
  7
</code></pre><p>Output:<br>7</p>
<p>其实这题运用逆向思维，先遍历right，再遍历left。</p>
<pre><code>public int findBottomLeftValue(TreeNode root) {
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (root.right != null) queue.add(root.right);
        if (root.left != null) queue.add(root.left);
    }
    return root.val;
}
</code></pre><h1 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h1><pre><code>    1
   / \
  2   3
 / \   \
4   5   6
</code></pre><p>层次遍历顺序：[1 2 3 4 5 6]</p>
<p>前序遍历顺序：[1 2 4 5 3 6]</p>
<p>中序遍历顺序：[4 2 5 1 3 6]</p>
<p>后序遍历顺序：[4 5 2 6 3 1]</p>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>① 前序</p>
<pre><code>void dfs(TreeNode root) {
    visit(root);
    dfs(root.left);
    dfs(root.right);
}
</code></pre><p>② 中序</p>
<pre><code>void dfs(TreeNode root) {
    dfs(root.left);
    visit(root);
    dfs(root.right);
}
</code></pre><p>③ 后序</p>
<pre><code>void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
</code></pre><h1 id="非递归实现二叉树的前序遍历"><a href="#非递归实现二叉树的前序遍历" class="headerlink" title="非递归实现二叉树的前序遍历"></a>非递归实现二叉树的前序遍历</h1><pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.right);  // 先右后左，保证左子树先遍历
        stack.push(node.left);
    }
    return ret;
}
</code></pre><h1 id="非递归实现二叉树的后序遍历"><a href="#非递归实现二叉树的后序遍历" class="headerlink" title="非递归实现二叉树的后序遍历"></a>非递归实现二叉树的后序遍历</h1><p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}
</code></pre><h1 id="非递归实现二叉树的中序遍历"><a href="#非递归实现二叉树的中序遍历" class="headerlink" title="非递归实现二叉树的中序遍历"></a>非递归实现二叉树的中序遍历</h1><pre><code>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}
</code></pre><h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>
<p>二叉查找树中序遍历有序。</p>
<h1 id="修剪二叉查找树"><a href="#修剪二叉查找树" class="headerlink" title="修剪二叉查找树"></a>修剪二叉查找树</h1><pre><code>Input:

    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:

      3
     /
   2
  /
 1
</code></pre><p>题目描述：只保留值在 L ~ R 之间的节点</p>
<pre><code>public TreeNode trimBST(TreeNode root, int L, int R) {
    if (root == null) return null;
    if (root.val &gt; R) return trimBST(root.left, L, R);
    if (root.val &lt; L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}
</code></pre><h1 id="寻找二叉查找树的第-k-个元素"><a href="#寻找二叉查找树的第-k-个元素" class="headerlink" title="寻找二叉查找树的第 k 个元素"></a>寻找二叉查找树的第 k 个元素</h1><p>中序遍历解法：</p>
<pre><code>private int cnt = 0;
private int val;

public int kthSmallest(TreeNode root, int k) {
    inOrder(root, k);
    return val;
}

private void inOrder(TreeNode node, int k) {
    if (node == null) return;
    inOrder(node.left, k);
    cnt++;
    if (cnt == k) {
        val = node.val;
        return;
    }
    inOrder(node.right, k);
}
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/tree/" rel="tag"># tree</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/28/进程和线程/" rel="next" title="进程和线程">
                <i class="fa fa-chevron-left"></i> 进程和线程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMjI3Mi84ODM2"></div>
    </div>

  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/upload_image/avatar.gif"
                alt="Kunrong" />
            
              <p class="site-author-name" itemprop="name">Kunrong</p>
              <p class="site-description motion-element" itemprop="description">share my technology</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/8311431967" target="_blank" title="github">
                    
                      <i class="fa fa-fw fa-globe"></i>github</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/1967-59-52/activities" target="_blank" title="zhihu">
                    
                      <i class="fa fa-fw fa-globe"></i>zhihu</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x524D;&#x8A00;" class="headerlink" title="&#x524D;&#x8A00;"></a>&#x524D;&#x8A00;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树的高度"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x6811;&#x7684;&#x9AD8;&#x5EA6;" class="headerlink" title="&#x6811;&#x7684;&#x9AD8;&#x5EA6;"></a>&#x6811;&#x7684;&#x9AD8;&#x5EA6;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#平衡树"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x5E73;&#x8861;&#x6811;" class="headerlink" title="&#x5E73;&#x8861;&#x6811;"></a>&#x5E73;&#x8861;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两节点的最长路径"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x4E24;&#x8282;&#x70B9;&#x7684;&#x6700;&#x957F;&#x8DEF;&#x5F84;" class="headerlink" title="&#x4E24;&#x8282;&#x70B9;&#x7684;&#x6700;&#x957F;&#x8DEF;&#x5F84;"></a>&#x4E24;&#x8282;&#x70B9;&#x7684;&#x6700;&#x957F;&#x8DEF;&#x5F84;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#翻转树"><span class="nav-number">5.</span> <span class="nav-text"><a href="#&#x7FFB;&#x8F6C;&#x6811;" class="headerlink" title="&#x7FFB;&#x8F6C;&#x6811;"></a>&#x7FFB;&#x8F6C;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#归并两棵树"><span class="nav-number">6.</span> <span class="nav-text"><a href="#&#x5F52;&#x5E76;&#x4E24;&#x68F5;&#x6811;" class="headerlink" title="&#x5F52;&#x5E76;&#x4E24;&#x68F5;&#x6811;"></a>&#x5F52;&#x5E76;&#x4E24;&#x68F5;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#判断路径和是否等于一个数"><span class="nav-number">7.</span> <span class="nav-text"><a href="#&#x5224;&#x65AD;&#x8DEF;&#x5F84;&#x548C;&#x662F;&#x5426;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;" class="headerlink" title="&#x5224;&#x65AD;&#x8DEF;&#x5F84;&#x548C;&#x662F;&#x5426;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;"></a>&#x5224;&#x65AD;&#x8DEF;&#x5F84;&#x548C;&#x662F;&#x5426;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#统计路径和等于一个数的路径数量"><span class="nav-number">8.</span> <span class="nav-text"><a href="#&#x7EDF;&#x8BA1;&#x8DEF;&#x5F84;&#x548C;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;&#x7684;&#x8DEF;&#x5F84;&#x6570;&#x91CF;" class="headerlink" title="&#x7EDF;&#x8BA1;&#x8DEF;&#x5F84;&#x548C;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;&#x7684;&#x8DEF;&#x5F84;&#x6570;&#x91CF;"></a>&#x7EDF;&#x8BA1;&#x8DEF;&#x5F84;&#x548C;&#x7B49;&#x4E8E;&#x4E00;&#x4E2A;&#x6570;&#x7684;&#x8DEF;&#x5F84;&#x6570;&#x91CF;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#是否包含子树"><span class="nav-number">9.</span> <span class="nav-text"><a href="#&#x662F;&#x5426;&#x5305;&#x542B;&#x5B50;&#x6811;" class="headerlink" title="&#x662F;&#x5426;&#x5305;&#x542B;&#x5B50;&#x6811;"></a>&#x662F;&#x5426;&#x5305;&#x542B;&#x5B50;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#镜像树"><span class="nav-number">10.</span> <span class="nav-text"><a href="#&#x955C;&#x50CF;&#x6811;" class="headerlink" title="&#x955C;&#x50CF;&#x6811;"></a>&#x955C;&#x50CF;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最小路径"><span class="nav-number">11.</span> <span class="nav-text"><a href="#&#x6700;&#x5C0F;&#x8DEF;&#x5F84;" class="headerlink" title="&#x6700;&#x5C0F;&#x8DEF;&#x5F84;"></a>&#x6700;&#x5C0F;&#x8DEF;&#x5F84;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#返回左叶子节点的和"><span class="nav-number">12.</span> <span class="nav-text"><a href="#&#x8FD4;&#x56DE;&#x5DE6;&#x53F6;&#x5B50;&#x8282;&#x70B9;&#x7684;&#x548C;" class="headerlink" title="&#x8FD4;&#x56DE;&#x5DE6;&#x53F6;&#x5B50;&#x8282;&#x70B9;&#x7684;&#x548C;"></a>&#x8FD4;&#x56DE;&#x5DE6;&#x53F6;&#x5B50;&#x8282;&#x70B9;&#x7684;&#x548C;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#间隔遍历"><span class="nav-number">13.</span> <span class="nav-text"><a href="#&#x95F4;&#x9694;&#x904D;&#x5386;" class="headerlink" title="&#x95F4;&#x9694;&#x904D;&#x5386;"></a>&#x95F4;&#x9694;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#层次遍历"><span class="nav-number">14.</span> <span class="nav-text"><a href="#&#x5C42;&#x6B21;&#x904D;&#x5386;" class="headerlink" title="&#x5C42;&#x6B21;&#x904D;&#x5386;"></a>&#x5C42;&#x6B21;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一棵树每层节点的平均数"><span class="nav-number">15.</span> <span class="nav-text"><a href="#&#x4E00;&#x68F5;&#x6811;&#x6BCF;&#x5C42;&#x8282;&#x70B9;&#x7684;&#x5E73;&#x5747;&#x6570;" class="headerlink" title="&#x4E00;&#x68F5;&#x6811;&#x6BCF;&#x5C42;&#x8282;&#x70B9;&#x7684;&#x5E73;&#x5747;&#x6570;"></a>&#x4E00;&#x68F5;&#x6811;&#x6BCF;&#x5C42;&#x8282;&#x70B9;&#x7684;&#x5E73;&#x5747;&#x6570;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#得到左下角的节点"><span class="nav-number">16.</span> <span class="nav-text"><a href="#&#x5F97;&#x5230;&#x5DE6;&#x4E0B;&#x89D2;&#x7684;&#x8282;&#x70B9;" class="headerlink" title="&#x5F97;&#x5230;&#x5DE6;&#x4E0B;&#x89D2;&#x7684;&#x8282;&#x70B9;"></a>&#x5F97;&#x5230;&#x5DE6;&#x4E0B;&#x89D2;&#x7684;&#x8282;&#x70B9;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前中后序遍历"><span class="nav-number">17.</span> <span class="nav-text"><a href="#&#x524D;&#x4E2D;&#x540E;&#x5E8F;&#x904D;&#x5386;" class="headerlink" title="&#x524D;&#x4E2D;&#x540E;&#x5E8F;&#x904D;&#x5386;"></a>&#x524D;&#x4E2D;&#x540E;&#x5E8F;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非递归实现二叉树的前序遍历"><span class="nav-number">18.</span> <span class="nav-text"><a href="#&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x524D;&#x5E8F;&#x904D;&#x5386;" class="headerlink" title="&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x524D;&#x5E8F;&#x904D;&#x5386;"></a>&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x524D;&#x5E8F;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非递归实现二叉树的后序遍历"><span class="nav-number">19.</span> <span class="nav-text"><a href="#&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;" class="headerlink" title="&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;"></a>&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x540E;&#x5E8F;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非递归实现二叉树的中序遍历"><span class="nav-number">20.</span> <span class="nav-text"><a href="#&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x4E2D;&#x5E8F;&#x904D;&#x5386;" class="headerlink" title="&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x4E2D;&#x5E8F;&#x904D;&#x5386;"></a>&#x975E;&#x9012;&#x5F52;&#x5B9E;&#x73B0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x4E2D;&#x5E8F;&#x904D;&#x5386;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BST"><span class="nav-number">21.</span> <span class="nav-text"><a href="#BST" class="headerlink" title="BST"></a>BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#修剪二叉查找树"><span class="nav-number">22.</span> <span class="nav-text"><a href="#&#x4FEE;&#x526A;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;" class="headerlink" title="&#x4FEE;&#x526A;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;"></a>&#x4FEE;&#x526A;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#寻找二叉查找树的第-k-个元素"><span class="nav-number">23.</span> <span class="nav-text"><a href="#&#x5BFB;&#x627E;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;&#x7684;&#x7B2C;-k-&#x4E2A;&#x5143;&#x7D20;" class="headerlink" title="&#x5BFB;&#x627E;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;&#x7684;&#x7B2C; k &#x4E2A;&#x5143;&#x7D20;"></a>&#x5BFB;&#x627E;&#x4E8C;&#x53C9;&#x67E5;&#x627E;&#x6811;&#x7684;&#x7B2C; k &#x4E2A;&#x5143;&#x7D20;</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kunrong</span>

  
</div>
<!--


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>
-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
